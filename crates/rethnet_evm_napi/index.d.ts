/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface AccessListItem {
  address: string
  storageKeys: Array<string>
}
export interface Bytecode {
  /** 256-bit code hash */
  readonly hash: Buffer
  /** Byte code */
  readonly code: Buffer
}
export interface Account {
  /** Account balance */
  readonly balance: bigint
  /** Account nonce */
  readonly nonce: bigint
  /** Optionally, byte code. Otherwise, hash is equal to `KECCAK_EMPTY` */
  readonly code?: Bytecode
}
export interface BlockConfig {
  number?: bigint
  coinbase?: Buffer
  timestamp?: bigint
  difficulty?: bigint
  prevrandao?: Buffer
  basefee?: bigint
  gasLimit?: bigint
  parentHash?: Buffer
}
export interface BlockHeader {
  parentHash: Buffer
  ommersHash: Buffer
  beneficiary: Buffer
  stateRoot: Buffer
  transactionsRoot: Buffer
  receiptsRoot: Buffer
  logsBloom: Buffer
  difficulty: bigint
  number: bigint
  gasLimit: bigint
  gasUsed: bigint
  timestamp: bigint
  extraData: Buffer
  mixHash: Buffer
  nonce: bigint
  baseFeePerGas?: bigint
}
/** Identifier for the Ethereum spec. */
export const enum SpecId {
  /** Frontier */
  Frontier = 0,
  /** Frontier Thawing */
  FrontierThawing = 1,
  /** Homestead */
  Homestead = 2,
  /** DAO Fork */
  DaoFork = 3,
  /** Tangerine */
  Tangerine = 4,
  /** Spurious Dragon */
  SpuriousDragon = 5,
  /** Byzantium */
  Byzantium = 6,
  /** Constantinople */
  Constantinople = 7,
  /** Petersburg */
  Petersburg = 8,
  /** Istanbul */
  Istanbul = 9,
  /** Muir Glacier */
  MuirGlacier = 10,
  /** Berlin */
  Berlin = 11,
  /** London */
  London = 12,
  /** Arrow Glacier */
  ArrowGlacier = 13,
  /** Gray Glacier */
  GrayGlacier = 14,
  /** Merge */
  Merge = 15,
  /** Shanghai */
  Shanghai = 16,
  /** Cancun */
  Cancun = 17,
  /** Latest */
  Latest = 18
}
/** If not set, uses defaults from [`CfgEnv`]. */
export interface Config {
  /** The blockchain's ID */
  chainId?: bigint
  /** Identifier for the Ethereum spec */
  specId?: SpecId
  /** The contract code size limit for EIP-170 */
  limitContractCodeSize?: bigint
  /** Disables block limit validation */
  disableBlockGasLimit?: boolean
  /** Disables EIP-3607, which rejects transactions from sender with deployed code */
  disableEip3607?: boolean
}
/** Ethereum log. */
export interface Log {
  address: Buffer
  topics: Array<Buffer>
  data: Buffer
}
export interface Receipt {
  cumulativeBlockGasUsed: bigint
  logsBloom: Buffer
  logs: Array<Log>
  status: boolean
}
/** An account that needs to be created during the genesis block. */
export interface GenesisAccount {
  /** Account private key */
  privateKey: string
  /** Account balance */
  balance: bigint
}
export interface Trace {
  steps: Array<Step>
  returnValue: Buffer
}
export interface Step {
  opcode: number
  gasCost: bigint
  gasRefunded: number
  exitCode: number
}
export interface TracingMessage {
  /** Recipient address. None if it is a Create message. */
  readonly to?: Buffer
  /** Depth of the message */
  readonly depth: number
  /** Input data of the message */
  readonly data: Buffer
  /** Value sent in the message */
  readonly value: bigint
  /**
   * Address of the code that is being executed. Can be different from `to` if a delegate call
   * is being done.
   */
  readonly codeAddress?: Buffer
  /** Code of the contract that is being executed. */
  readonly code?: Buffer
}
export interface TracingStep {
  /** Call depth */
  readonly depth: number
  /** The program counter */
  readonly pc: bigint
  /** The executed op code */
  readonly opcode: string
  /** The amount of gas that was used by the step */
  readonly gasCost: bigint
  /** The amount of gas that was refunded by the step */
  readonly gasRefunded: bigint
  /** The amount of gas left */
  readonly gasLeft: bigint
  /** The stack */
  readonly stack: Array<bigint>
  /** The memory */
  readonly memory: Buffer
  /** The contract being executed */
  readonly contract: Account
  /** The address of the contract */
  readonly contractAddress: Buffer
}
export interface TracingMessageResult {
  /** Execution result */
  readonly executionResult: ExecutionResult
}
export interface TracingCallbacks {
  beforeMessage: (message: TracingMessage, next: any) => Promise<void>
  step: (step: TracingStep, next: any) => Promise<void>
  afterMessage: (result: TracingMessageResult, next: any) => Promise<void>
}
/** The possible reasons for successful termination of the EVM. */
export const enum SuccessReason {
  /** The opcode `STOP` was called */
  Stop = 0,
  /** The opcode `RETURN` was called */
  Return = 1,
  /** The opcode `SELFDESTRUCT` was called */
  SelfDestruct = 2
}
export interface CallOutput {
  /** Return value */
  returnValue: Buffer
}
export interface CreateOutput {
  /** Return value */
  returnValue: Buffer
  /** Optionally, a 160-bit address */
  address?: Buffer
}
/** The result when the EVM terminates successfully. */
export interface SuccessResult {
  /** The reason for termination */
  reason: SuccessReason
  /** The amount of gas used */
  gasUsed: bigint
  /** The amount of gas refunded */
  gasRefunded: bigint
  /** The logs */
  logs: Array<Log>
  /** The transaction output */
  output: CallOutput | CreateOutput
}
/** The result when the EVM terminates due to a revert. */
export interface RevertResult {
  /** The amount of gas used */
  gasUsed: bigint
  /** The transaction output */
  output: Buffer
}
/**
 * Indicates that the EVM has experienced an exceptional halt. This causes execution to
 * immediately end with all gas being consumed.
 */
export const enum ExceptionalHalt {
  OutOfGas = 0,
  OpcodeNotFound = 1,
  InvalidFEOpcode = 2,
  InvalidJump = 3,
  NotActivated = 4,
  StackUnderflow = 5,
  StackOverflow = 6,
  OutOfOffset = 7,
  CreateCollision = 8,
  OverflowPayment = 9,
  PrecompileError = 10,
  NonceOverflow = 11,
  /** Create init code size exceeds limit (runtime). */
  CreateContractSizeLimit = 12,
  /** Error on created contract that begins with EF */
  CreateContractStartingWithEF = 13
}
/** The result when the EVM terminates due to an exceptional halt. */
export interface HaltResult {
  /** The exceptional halt that occurred */
  reason: ExceptionalHalt
  /** Halting will spend all the gas and will thus be equal to the specified gas limit */
  gasUsed: bigint
}
/** The result of executing a transaction. */
export interface ExecutionResult {
  /** The transaction result */
  result: SuccessResult | RevertResult | HaltResult
  /** The transaction trace */
  trace: Array<TracingMessage | TracingStep | TracingMessageResult>
}
export interface TransactionResult {
  execResult: ExecutionResult
  state: any
}
export interface Transaction {
  /**
   * 160-bit address for caller
   * Defaults to `0x00.0` address.
   */
  from?: Buffer
  /**
   * 160-bit address for receiver
   * Creates a contract if no address is provided.
   */
  to?: Buffer
  /**
   * Maximum gas allowance for the code execution to avoid infinite loops.
   * Defaults to 2^63.
   */
  gasLimit?: bigint
  /**
   * Number of wei to pay for each unit of gas during execution.
   * Defaults to 1 wei.
   */
  gasPrice?: bigint
  /** Maximum tip per gas that's given directly to the forger. */
  gasPriorityFee?: bigint
  /** (Up to) 256-bit unsigned value. */
  value?: bigint
  /** Nonce of sender account. */
  nonce?: bigint
  /** Input byte data */
  input?: Buffer
  /** A list of addresses and storage keys that the transaction plans to access. */
  accessList?: Array<AccessListItem>
  /** Transaction is only valid on networks with this chain ID. */
  chainId?: bigint
}
export interface TransactionConfig {
  disableBalanceCheck?: boolean
}
export class BlockBuilder {
  static new(blockchain: Blockchain, stateManager: StateManager, config: Config, parent: BlockHeader, block: BlockConfig): BlockBuilder
  addTransaction(transaction: Transaction): Promise<ExecutionResult>
  /**
   * This call consumes the [`BlockBuilder`] object in Rust. Afterwards, you can no longer call
   * methods on the JS object.
   */
  finalize(rewards: Array<[Buffer, bigint]>): Promise<void>
  /**
   * This call consumes the [`BlockBuilder`] object in Rust. Afterwards, you can no longer call
   * methods on the JS object.
   */
  abort(): Promise<void>
}
/** The Rethnet blockchain */
export class Blockchain {
  /** Constructs a new blockchain that queries the blockhash using a callback. */
  constructor(getBlockHashFn: (blockNumber: bigint) => Promise<Buffer>)
}
/** The Rethnet runtime, which can execute individual transactions. */
export class Rethnet {
  /** Constructs a `Rethnet` runtime. */
  constructor(blockchain: Blockchain, stateManager: StateManager, cfg: Config)
  /** Executes the provided transaction without changing state. */
  dryRun(transaction: Transaction, block: BlockConfig): Promise<TransactionResult>
  /** Executes the provided transaction without changing state, ignoring validation checks in the process. */
  guaranteedDryRun(transaction: Transaction, block: BlockConfig): Promise<TransactionResult>
  /** Executes the provided transaction, changing state in the process. */
  run(transaction: Transaction, block: BlockConfig): Promise<ExecutionResult>
}
/** The Rethnet state */
export class StateManager {
  /** Constructs a [`StateManager`] with an empty state. */
  constructor()
  /** Constructs a [`StateManager`] with the provided accounts present in the genesis state. */
  static withGenesisAccounts(accounts: Array<GenesisAccount>): StateManager
  /** Creates a state checkpoint that can be reverted to using [`revert`]. */
  checkpoint(): Promise<void>
  /** Reverts to the previous checkpoint, created using [`checkpoint`]. */
  revert(): Promise<void>
  /** Retrieves the account corresponding to the specified address. */
  getAccountByAddress(address: Buffer): Promise<Account | null>
  /** Retrieves the storage root of the account at the specified address. */
  getAccountStorageRoot(address: Buffer): Promise<Buffer | null>
  /** Retrieves the storage slot at the specified address and index. */
  getAccountStorageSlot(address: Buffer, index: bigint): Promise<bigint>
  /** Retrieves the storage root of the database. */
  getStateRoot(): Promise<Buffer>
  /** Inserts the provided account at the specified address. */
  insertAccount(address: Buffer, account: Account): Promise<void>
  /** Makes a snapshot of the database that's retained until [`removeSnapshot`] is called. Returns the snapshot's identifier. */
  makeSnapshot(): Promise<Buffer>
  /**
   * Modifies the account with the provided address using the specified modifier function.
   * The modifier function receives the current values as individual parameters and will update the account's values
   * to the returned `Account` values.
   */
  modifyAccount(address: Buffer, modifyAccountFn: (balance: bigint, nonce: bigint, code: Bytecode | undefined) => Promise<Account>): Promise<void>
  /** Removes and returns the account at the specified address, if it exists. */
  removeAccount(address: Buffer): Promise<Account | null>
  /** Removes the snapshot corresponding to the specified state root, if it exists. Returns whether a snapshot was removed. */
  removeSnapshot(stateRoot: Buffer): Promise<boolean>
  /** Sets the storage slot at the specified address and index to the provided value. */
  setAccountStorageSlot(address: Buffer, index: bigint, value: bigint): Promise<void>
  /** Reverts the state to match the specified state root. */
  setStateRoot(stateRoot: Buffer): Promise<void>
}
export class Tracer {
  constructor(callbacks: TracingCallbacks)
}
